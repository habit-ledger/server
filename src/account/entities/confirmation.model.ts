import { PrimaryColumn, Column, Entity, JoinColumn, OneToOne } from "typeorm";
import { AccountModel } from "./account.model";

/**
 * ConfirmationModel represents the 1 record that is created at the time of registration for
 * a user's account to confirm that they are a real person. The user is NOT required to actually
 * confirm their email, since that is out of scope for this project, but this is still created
 * in case I want to add email notifications for the future where only _confirmed_ emails are
 * sent notifications
 */
@Entity({ name: 'account_confirmations', schema: 'app' })
export class ConfirmationModel {

  @Column({ type: 'timestamptz', nullable: false, name: 'created_at' })
  public createdAt: Date;

  /**
   * This is set upon the time of confirming the user, using the `.confirm` method on this model.
   */
  @Column({ type: 'timestamptz', name: 'confirmed_at' })
  public confirmedAt: Date | null;

  /**
   * Code is automatically generated by the database on save, and thus is not required to set
   * by us. We DO have to check if there is an error upon insertion, because this is required
   * unique, but it uses the MD5 of a UUID_v4 to generate a new code. It's unlikely to have an
   * accidental dupe, but it is possible.
   */
  @Column({ type: 'char', nullable: false, length: 32 })
  public code: string;

  @PrimaryColumn({ type: 'uuid', name: 'user_id' })
  public userId: string;

  @OneToOne(() => AccountModel)
  @JoinColumn({ name: 'user_id', referencedColumnName: 'id' })
  public user: AccountModel;

  /**
   * This simply sets the confirmedAt date to now. Reason being is that we should be retrieving
   * this model using the code, so if there's no match, no record is returned.
   */
  public confirm(): void {
    this.confirmedAt = new Date();
  }
}
